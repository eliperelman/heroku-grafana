/*! grafana - v2.6.0 - 2015-12-14
 * Copyright (c) 2015 Torkel Ã–degaard; Licensed Apache-2.0 */

define(["require","exports","app/plugins/datasource/graphite/gfunc","test/specs/helpers","test/lib/common","app/plugins/datasource/graphite/query_ctrl","app/core/services/segment_srv"],function(a,b,c,d,e){e.describe("GraphiteQueryCtrl",function(){var a=new d.ControllerTestContext;e.beforeEach(e.angularMocks.module("grafana.core")),e.beforeEach(e.angularMocks.module("grafana.controllers")),e.beforeEach(e.angularMocks.module("grafana.services")),e.beforeEach(a.providePhase()),e.beforeEach(a.createControllerPhase("GraphiteQueryCtrl")),e.beforeEach(function(){a.scope.target={target:"aliasByNode(scaleToSeconds(test.prod.*,1),2)"},a.scope.datasource=a.datasource,a.scope.datasource.metricFindQuery=e.sinon.stub().returns(a.$q.when([]))}),e.describe("init",function(){e.beforeEach(function(){a.scope.init(),a.scope.$digest()}),e.it("should validate metric key exists",function(){e.expect(a.scope.datasource.metricFindQuery.getCall(0).args[0]).to.be("test.prod.*")}),e.it("should delete last segment if no metrics are found",function(){e.expect(a.scope.segments[2].value).to.be("select metric")}),e.it("should parse expression and build function model",function(){e.expect(a.scope.functions.length).to.be(2)})}),e.describe("when adding function",function(){e.beforeEach(function(){a.scope.target.target="test.prod.*.count",a.scope.datasource.metricFindQuery.returns(a.$q.when([{expandable:!1}])),a.scope.init(),a.scope.$digest(),a.scope.$parent={get_data:e.sinon.spy()},a.scope.addFunction(c.getFuncDef("aliasByNode"))}),e.it("should add function with correct node number",function(){e.expect(a.scope.functions[0].params[0]).to.be(2)}),e.it("should update target",function(){e.expect(a.scope.target.target).to.be("aliasByNode(test.prod.*.count, 2)")}),e.it("should call get_data",function(){e.expect(a.scope.$parent.get_data.called).to.be(!0)})}),e.describe("when adding function before any metric segment",function(){e.beforeEach(function(){a.scope.target.target="",a.scope.datasource.metricFindQuery.returns(a.$q.when([{expandable:!0}])),a.scope.init(),a.scope.$digest(),a.scope.$parent={get_data:e.sinon.spy()},a.scope.addFunction(c.getFuncDef("asPercent"))}),e.it("should add function and remove select metric link",function(){e.expect(a.scope.segments.length).to.be(0)})}),e.describe("when initalizing target without metric expression and only function",function(){e.beforeEach(function(){a.scope.target.target="asPercent(#A, #B)",a.scope.datasource.metricFindQuery.returns(a.$q.when([])),a.scope.init(),a.scope.$digest(),a.scope.$parent={get_data:e.sinon.spy()}}),e.it("should not add select metric segment",function(){e.expect(a.scope.segments.length).to.be(0)}),e.it("should add both series refs as params",function(){e.expect(a.scope.functions[0].params.length).to.be(2)})}),e.describe("when initializing a target with single param func using variable",function(){e.beforeEach(function(){a.scope.target.target="movingAverage(prod.count, $var)",a.scope.datasource.metricFindQuery.returns(a.$q.when([])),a.scope.init(),a.scope.$digest(),a.scope.$parent={get_data:e.sinon.spy()}}),e.it("should add 2 segments",function(){e.expect(a.scope.segments.length).to.be(2)}),e.it("should add function param",function(){e.expect(a.scope.functions[0].params.length).to.be(1)})}),e.describe("when initalizing target without metric expression and function with series-ref",function(){e.beforeEach(function(){a.scope.target.target="asPercent(metric.node.count, #A)",a.scope.datasource.metricFindQuery.returns(a.$q.when([])),a.scope.init(),a.scope.$digest(),a.scope.$parent={get_data:e.sinon.spy()}}),e.it("should add segments",function(){e.expect(a.scope.segments.length).to.be(3)}),e.it("should have correct func params",function(){e.expect(a.scope.functions[0].params.length).to.be(1)})}),e.describe("when getting altSegments and metricFindQuery retuns empty array",function(){e.beforeEach(function(){a.scope.target.target="test.count",a.scope.datasource.metricFindQuery.returns(a.$q.when([])),a.scope.init(),a.scope.getAltSegments(1).then(function(b){a.altSegments=b}),a.scope.$digest(),a.scope.$parent={get_data:e.sinon.spy()}}),e.it("should have no segments",function(){e.expect(a.altSegments.length).to.be(0)})}),e.describe("targetChanged",function(){e.beforeEach(function(){a.scope.datasource.metricFindQuery.returns(a.$q.when([{expandable:!1}])),a.scope.init(),a.scope.$digest(),a.scope.$parent={get_data:e.sinon.spy()},a.scope.target.target="",a.scope.targetChanged()}),e.it("should rebuld target after expression model",function(){e.expect(a.scope.target.target).to.be("aliasByNode(scaleToSeconds(test.prod.*, 1), 2)")}),e.it("should call get_data",function(){e.expect(a.scope.$parent.get_data.called).to.be(!0)})})})});